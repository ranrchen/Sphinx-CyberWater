from vistrails.core.modules.vistrails_module import Module, ModuleError
from vistrails.core.modules.basic_modules import NotCacheable, String, Boolean, Integer
from vistrails_helpers.utils.vistrail_types import STRING_TYPE, BOOLEAN_TYPE, VARIANT_TYPE, INTEGER_TYPE
from vistrails.core.modules.config import IPort, CIPort, OPort
from msm_core.msm_srv.task_cache.TaskCache import TaskCache
from vistrails.core.modules.module_registry import get_module_registry
from datetime import datetime
from util.OutputUtil import OutputUtil
from util.DocumentUtil import DocumentUtil
import os
import shutil
import uuid
import subprocess
import sys


class RunModuleAgent(Module, NotCacheable):
    """
    RunModuleAgent responsible for the execution of a Model offered as executable. 
    The model execution requires that the user manually prepares the files required.

    :Input Ports:
        :01_Output_Name: The list of the name of the output dataset
        :02_File_Position: The list of the position (column index) in the result files (e.g. model results files) for the corresponding output dataset.
        :03_Model_executable:
            - **exe:** executable file with the execution parameters excluding the arguments.
            - **arg:** arguments required for the execution.
        :04_Results_format:
            - **Result_File_Prefix/Name:** Either the prefix of all the cells generated by the model. Or the name of the time-series generated.
            - **Result_File_Separator:** Separation character in the output files.
            - **Result_Folder:** The name of the folder saving the result data. The default value is *results*
            - **Point_output?:** Check if the output is a single time-series in contrast of a distributed result in multiple files, once per cell.  The defalut value is *False*.
            - **Header_lines:** Number of lines at the top of the resulting files that need to be ignored.
        :05_Final_state_options [Optional]:
            - **final_state_name:** The name of the final state file.
            - **save_path:** The saving path of the final state file.
        :Ready_List: Connect the output of ForcingDataFileGenerator, AreaWiseParamGenerator and InitialStateFileGenerator if it exists.
        :WD_Path: WD_Path output port of the MainGenerator. This is the directory where the simulation files are saved.
        :DataSet_Class: DataSet_Class output port of the MainGenerator.

    :Output Ports:
        - **Outputx:**  Output dataset x. (x=01,02,03,....,20)
    """
    OUTPUT_NAME = "01_Output_Name"
    FILE_POSITION = "02_File_Position"
    MODEL_EXECUTABLE = "03_Model_executable"
    RESULTS_FORMAT = "04_Results_format"
    FINAL_STATE_OPTIONS = "05_Final_state_options"

    SAVE_CACHE = "save_cache?"

    WRITE_EMPTY_VALUE = None
    taskCache = TaskCache()

    _input_ports = [('Ready_List', VARIANT_TYPE),
                    ('WD_Path', STRING_TYPE),
                    ('DataSet_Class', STRING_TYPE),
                    IPort(name=SAVE_CACHE, signature=BOOLEAN_TYPE, default=True, optional=True),
                    IPort(name=OUTPUT_NAME, signature="basic:String", depth=1, optional=True),
                    IPort(name=FILE_POSITION, signature="basic:String", depth=1, optional=True),
                    CIPort(MODEL_EXECUTABLE, [String, String], optional=True, labels=["<b>exe</b>", "<b>arg</b>"]),
                    CIPort(RESULTS_FORMAT, [String, String, String, Boolean, Integer], optional=True, defaults=["", 'results', "\\tab", False, 0],labels=["<b>Result_File_Prefix/Name</b>", "<b>Results_Folder</b>", "<b>Result_File_Separator</b>","<b>Point_output?</b>", "<b>Header_lines</b>"]),
                    CIPort(FINAL_STATE_OPTIONS, [String, String], optional=True, defaults=["", ""], labels=[ "<b>final_state_name</b>", "<b>save_path</b>"])
                    ]
  

    _output_ports = [('Output01', STRING_TYPE),
                     ('Output02', STRING_TYPE, {"optional": True}),
                     ('Output03', STRING_TYPE, {"optional": True}),
                     ('Output04', STRING_TYPE, {"optional": True}),
                     ('Output05', STRING_TYPE, {"optional": True}),
                     ('Output06', STRING_TYPE, {"optional": True}),
                     ('Output07', STRING_TYPE, {"optional": True}),
                     ('Output08', STRING_TYPE, {"optional": True}),
                     ('Output09', STRING_TYPE, {"optional": True}),
                     ('Output10', STRING_TYPE, {"optional": True}),
                     ('Output11', STRING_TYPE, {"optional": True}),
                     ('Output12', STRING_TYPE, {"optional": True}),
                     ('Output13', STRING_TYPE, {"optional": True}),
                     ('Output14', STRING_TYPE, {"optional": True}),
                     ('Output15', STRING_TYPE, {"optional": True}),
                     ('Output16', STRING_TYPE, {"optional": True}),
                     ('Output17', STRING_TYPE, {"optional": True}),
                     ('Output18', STRING_TYPE, {"optional": True}),
                     ('Output19', STRING_TYPE, {"optional": True}),
                     ('Output20', STRING_TYPE, {"optional": True})]

    def compute(self):
        """
        The main function of RunModuleAgent module is to execute a model offered as executable and prepare the files required for execution
        """
        # Getting Inputs -----------------------------------------------------------------------------------------------
        output = OutputUtil()
        ret = []
        dd = None

        Dataset_in = self.force_get_input("DataSet_Class")
        Ready_List = self.force_get_input_list("Ready_List")
        Path = self.force_get_input("WD_Path")

        save_cache = self.force_get_input(self.SAVE_CACHE)

        # 01 Getting output name list ==================
        self.Output_name = []
        output_names = ""
        outputname = self.force_get_input(self.OUTPUT_NAME)
        for on in outputname:
            if on:
                output_names = output_names+on
                self.Output_name.append(on)

        # 02 Getting file position list ================
        self.Position_list = []
        position_numbers = ""
        positionlist = self.force_get_input(self.FILE_POSITION)
        for pl in positionlist:
            if pl:
                position_numbers = position_numbers + pl
                self.Position_list.append(pl)

        # 03 Getting Model executable configuration ====
        exe_config = self.force_get_input(self.MODEL_EXECUTABLE)
        [exe, arg] = self.extract_exe_and_arg(exe_config)

        # 04 Getting results format state options   ====
        results_format = self.force_get_input(self.RESULTS_FORMAT)
        [file_name, results_directory, separator, point_output, number_of_header_lines] = self.extract_results_format(results_format)

        # 05 Getting save state options ================
        final_state_options = self.force_get_input(self.FINAL_STATE_OPTIONS)
        [final_state_name, final_state_dir] = self.extract_final_state_options(final_state_options)

        # Checking Inputs and provide defaults -------------------------------------------------------------------------
        if Ready_List is None or Ready_List == "": raise Exception("Ready_List is empty or undefined.")
        if Path is None or Path == "": raise Exception("WD_Path is empty or undefined.")
        if Dataset_in is None or Dataset_in == "": raise Exception("DataSet_Class is empty or undefined.")
        if exe is None or exe == "": raise Exception("exe is empty or undefined.")
        if arg is None or arg == "": print("WARNING: 'arg' is empty")

        if point_output is None or point_output == "": point_output = False
        if save_cache is None or save_cache == "": save_cache = False
        if number_of_header_lines is None or number_of_header_lines == "": number_of_header_lines = 0
        if separator is None or separator == "": separator = None
        for single_ready in Ready_List:
            if not single_ready: raise Exception("Some of the components are not ready.")
        for key in sorted(Dataset_in):
            if Dataset_in[key] is None:
                    del Dataset_in[key]

        # Start Computing ----------------------------------------------------------------------------------------------
        # Will this be cached?
        inputs = str(Dataset_in) + str(Ready_List) + Path + arg + exe + file_name + str(separator) + str(point_output)
        inputs += str(number_of_header_lines)
        if file_name:
            inputs += file_name
        inputs += str(point_output)
        inputs += str(number_of_header_lines)
        inputs += str(separator)
        inputs += str(output_names)
        inputs += str(position_numbers)

        input_identification = [inputs + str(datetime.now()), inputs][save_cache] # inputs#+str(datetime.now())
        input_identification = uuid.uuid5(uuid.NAMESPACE_DNS, input_identification)
        input_identification = str(input_identification)

        exe_str = os.path.basename(exe)
        files_dir = Path
        dd = output.check_dimensions(Dataset_in, dd)
        # should_run(input_identification)# Yuan TODO: this function return True or False
        cached_result = self.taskCache.get_task_cached_result_dataset_names_by_port(input_identification)  # TODO Figure out a better way to cache info

        if cached_result is not None:
            print(("cached_result", cached_result))
            # return cached_result[]
            for i in range(1, len(cached_result) + 1):
                temp = 'Output%02d' % (i)
                self.set_output(temp, cached_result[self.Output_name[i - 1]])

        else:
            if results_directory != "":
                results_full_path = os.path.join(files_dir, results_directory)
            else:
                results_full_path = files_dir
            if os.path.exists(results_full_path):
                shutil.rmtree(results_full_path)
            os.makedirs(results_full_path, mode=0o777)

            # Execute the executable
            exe_result = -1
            iter = 0
            print(("EXECUTING:", exe + ' ' + arg, files_dir))
            while exe_result < 0:
                iter += 1
                exe_result = subprocess.call(exe + ' ' + arg, shell=True, stdout=None, stderr=None, cwd=files_dir)
                if iter > 1: break
            #print('\n exe_result', exe_result,'\n')
            if exe_result < 0:
                raise Exception("The '%s' executable failed to run successfully." % exe)

            sys.stdout.flush()
            sys.stderr.flush()
            if final_state_name != "":
                state_file_path = os.path.join(Path, final_state_name)
                dst =  os.path.join(final_state_dir, final_state_name)
                shutil.copy(state_file_path, dst)

            print(("Preparing outputs:",))
            output_folder = os.path.join(files_dir, results_directory)
            module_name = self.__class__.__name__
            outputs,ret = output.save_outputs(output_folder, self.Output_name, self.Position_list, file_name, input_identification, point_output, separator, number_of_header_lines, module_name, ret,dd)
            print(("outputs", outputs))
            for i in range(1,len(outputs)+1):
                temp = 'Output%02d'%(i)
                self.set_output(temp, ret[i-1])

    def extract_results_format(self, results_format):
        """
        This Function is to extract the parameters on the format of results from GUI input panel

        :param results_format: The list of entries on the format of results configured by user on GUI
        :type results_format: list
        :return: The list of the value extracted from each entry on the format of results
        :rtype: list
        """
        #print results_format
        if results_format is not None:
            if len(results_format) == 5:
                file_name = results_format[0]
                results_directory = [results_format[1], "results"][results_format[1] == '']
                separator = [results_format[2], None][results_format[2] == '']
                point_output = results_format[3]
                number_of_header_lines = results_format[4]
            else:
                raise Exception("Results_format is filled incorrectly: %s" % results_format)
        else:
            raise Exception("Results_format is empty. 'Result_File_Prefix/Name' is mandatory.")
        #print "results_format", [file_name, results_directory, separator, point_output, number_of_header_lines], type(results_format)
        return [file_name, results_directory, separator, point_output, number_of_header_lines]

    def extract_final_state_options(self, final_state_options):
        """
        This Function is to extract the parameters on the final state options from GUI input panel

        :param final_state_options: The list of entries on the final state options configured by user on GUI
        :type final_state_options: list
        :return: The list of the value extracted from each entry on final state options
        :rtype: list
        """
        if final_state_options is not None:
            if len(final_state_options) == 2:
                final_state_name = final_state_options[0]
                final_state_dir = final_state_options[1]
            else:
                raise Exception("Final_state_options is filled incorrectly: %s" % final_state_options)
        else:
            [final_state_name, final_state_dir] = ["", ""]
        #print "final_state_options", final_state_options, type(final_state_options)
        return [final_state_name, final_state_dir]

    def extract_exe_and_arg(self, exe_config):
        """
        This Function is to extract the parameters on the executable program path and arguments from GUI input panel

        :param final_state_options: The list of entries on the executable program path and arguments configured by user on GUI
        :type final_state_options: list
        :return: The list of the value extracted from each entry on the executable program path and arguments
        :rtype: list
        """
        if exe_config is not None:
            if len(exe_config)>0:
                if isinstance(exe_config[0], str):
                    exe = r''+exe_config[0]
                    arg = r''+exe_config[1]
                else:
                    raise Exception("Executable and argument (%s) are not text. Format is unexpected:" % (exe_config))
            else:
                raise Exception("Executable and argument configuration are not filled or filled incorrectly: %s" % exe_config)
        else:
            raise Exception("Executable and argument inputs must be filled. They are emply.")
        #print "exe_config", exe_config, type(exe_config)
        return [exe, arg]

    @classmethod
    def get_documentation(cls, docstring, module=None):
        """
        This function is to get the documentation of RunModuleAgent module

        :param docstring: A string used to document a RunModuleAgent module
        :param module: RunModuleAgent module
        :return: A invoked function from package DocumentUtil to get documentation of RunModuleAgent module
        """
        module_name = cls.__dict__['__module__'].split(".")[-1]
        return DocumentUtil.get_documentation(module_name)


def initialize(*args, **keywords):
    """
    This function is to initialize the RunModuleAgent module
    """
    reg = get_module_registry()
    reg.add_module(RunModuleAgent)